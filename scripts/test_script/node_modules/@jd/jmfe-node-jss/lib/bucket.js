/**
 * @file
 * @author Zeng Tong
 * Created on 2017-09-07.
 */

'use strict';
const _ = require('lodash');
const Promise = require('bluebird');
const fs = Promise.promisifyAll(require('fs'));
const path = require('path');
const JssObject = require('./object');
const Acl = require('./acl');
let glob = null;

/**
 * Bucket 类型 <br>
 * Bucket是存放“文件”（云存储称之为Object）的容器，所有的Object都必须存放到某个Bucket中。
 *
 */
class Bucket {
    /**
     * 创建一个 Bucket 实例
     * @public
     * @param {string} name Bucket 名称
     * @param {Client} client Client 实例
     */
    constructor(name, client) {
        this.name = name;
        this.client = client;
        if (!( _.isString(name) && name.trim().length > 0)) {
            return new Error('参数 name 必须为非空字符串');
        }
    }

    /**
     *新建一个 Bucket <br>
     *每个用户最多可以创建 100个Bucket，每个 Bucket 中可以存放无限多个 Object。Bucket 不能嵌套。 <br>
     *Bucket 的名称全局唯一且严格的限制，包括： <br>
     * 1. 仅包含小写英文字母（a-z），数字，点（.）和横线（-）<br>
     * 2. 必须由字母或数字开头和结尾<br>
     * 3. 长度在 3 和 63 个字符之间<br>
     * 4. 不能为IP地址形式，比如192.168.1.1<br>
     * 5. 不能包含连续的点（.）与横线(-)组合<br>
     * @public
     * @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 200, 返回的Body为空; <br>
     * @returns {Promise.<Error>} reject，失败是为错误对象
     * @example
     * ```js
     * var bkt=jss.bucket('test-bucket');
     * bkt.create().then((res)=>{
     *     console.log('新建 bucket 成功');
     * }.catch((err)=>{
     *     console.log('新建 bucket 失败：'+err.message);
     * })
     * ```
     */
    create() {
        var self = this;
        var name = self.name;
        var request = {
            method: 'PUT',
            uri: '/' + name
        };
        var createResult = self.client.execute(request);
        return createResult;
    }

    /**
     *删除一个 Bucket <br>
     * @public
     * @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 204, 返回的Body为空; <br>
     * @returns {Promise.<Error>} reject，失败时为错误对象
     * @example
     *```js
     * var bkt=jss.bucket('test-bucket');
     * bkt.delete().then((res)=>{
     *     console.log('删除 bucket 成功');
     * }.catch((err)=>{
     *     console.log('删除 bucket 失败：'+err.message);
     * })
     *```
     */
    delete() {
        var self = this;
        var name = self.name;
        var request = {
            method: 'DELETE',
            uri: '/' + name
        };
        var createResult = self.client.execute(request);
        return createResult;
    }

    /**
     * 创建一个 JssObject
     * @public
     * @param {string} key Object的名字;
     * @returns {JssObject} 新建的 JssObject 对象
     * @example
     * var object=jss.bucket('bucket-name').object('object-name')
     */
    object(key) {
        var self = this;
        return new JssObject(key, this, self.client);
    }

    /**
     * 创建一个 acl 对象
     * @public
     * @returns {Acl} 新建的 acl 对象
     * @example
     * var acl=jss.bucket('bucket-name').acl()
     */
    acl() {
        var self = this;
        return new Acl(this, self.client);
    }


    /**
     * 列出 指定Bucket中的Object信息列表<br>
     * 请求时可以通过一些查询条件来限制返回的结果。<br>
     * @public
     * @param {string} marker 返回以字典序排序的 Object 信息的起始标志，结果中不包含marker，通常与max-keys一起使用来实现分页
     * @param {integer} maxKeys 返回Object信息的数量，最大为1000，若有更多符合查询条件的Object信息没有被返回，则响应中会包含HasNext为true元素，同时可以设定marker为本次列表最后一个Key，来获取其他的本次操作未返回的Object信息。默认为1000
     * @param {integer} prefix 限制返回Object的Key的前缀
     * @param {integer} delimiter 分组符，用于分组返回的Object的Key。当prefix未指定时，从Object的Key中提取第一个字符到第一个delimiter之间的字符串放在CommonPrefixes中返回。若指定了prefix，则提取prefix到第一个delimiter之间的字符串放在CommonPrefixes中返回
     * @returns {Promise.<Response.body>} resolve，成功时 statusCode 为 200, 返回的 Body 为 json 格式，包含以下字段： <br>
     *
     *| 字段 | 含义 |
     *| --- | --- |
     *| Name | Bucket的名称 |
     *| Delimiter | 指定的Delimiter分组符 |
     *| Prefix | 指定的Object Key的前缀 |
     *| MaxKeys | 指定的Object的数量 |
     *| Marker | 指定的Object的Key的起始标志 |
     *| NextMarker | 列出下一个集合的Marker，只有当用户设置了delimiter 且 HasNext为true时才会出现，其值可能是当前集合中最后一个Key，或是CommonPrefixes中最后一个Prefix, 若用户没有设置delimiter，且HasNext为true时，可以直接将返回集合中的最后一个Key作为列出下一个结合的Marker |
     *| HasNext | 标识返回的结果是否完整 （true or false），若符合条件的Object 信息数量超过了指定的MaxKeys，则该值为true，且多余的结果也不会被返回。 |
     *| Contents | 包含了一个Object信息的容器 |
     *| Key | Object的Key |
     *| LastModified | Object的最后修改时间 |
     *| ETag | Object的ETag是一个MD5 hash值，其只反映Object内容的变化，而不是元数据(Metadata) |
     *| Size | Object的大小 |
     *| CommonPrefixes | 用户指定了Delimiter时，该元素才会出现。用于存放分组后Object Key前缀。 |
     *
     *<br>
     *例如：
     *
     *```js
     *{ Name: 'pro-test',
     *  Prefix: null,
     *  Marker: null,
     *  Delimiter: null,
     *  MaxKeys: 2,
     *  HasNext: true,
     *  Contents:
     *   [ { Key: 'pro-a.txt',
     *       LastModified: 'Mon, 11 Sep 2017 17:47:04 GMT',
     *       ETag: '0cc175b9c0f1b6a831c399e269772661',
     *       Size: 1 },
     *     { Key: 'pro-b.txt',
     *       LastModified: 'Mon, 11 Sep 2017 17:47:15 GMT',
     *       ETag: '92eb5ffee6ae2fec3ad71c777531578f',
     *       Size: 1 } ],
     *  CommonPrefixes: null }
     *```
     * <br>
     *
     * @returns {Promise.<Error>} reject，失败是为错误对象
     * @example
     * jss.bucket('pro-test').listObject(undefined, 2, '', undefined).then((res)=> {
    console.log(res);
    if (res.HasNext) {
        var marker = res.Contents[res.Contents.length - 1].Key;
        jss.bucket('pro-test').listObject(marker, 1000).then((res)=> {
            console.log(res)
        }).catch((err)=> {
            console.log('listObject 2 失败：' + err.message);
        })
    }
}).catch((err)=> {
    console.log('listObject 1 失败：' + err.message);
})
     */
    listObject(marker, maxKeys, prefix, delimiter) {
        var self = this;
        var name = self.name;
        var request = {
            method: 'GET',
            uri: '/' + name,
            qs: {
                marker: marker,
                maxKeys: maxKeys,
                prefix: prefix,
                delimiter: delimiter
            }
        };
        return self.client.execute(request);
    }

    /**
     * 上传本地指定目录下的所有文件，可以在options中对需要上传的文件进行过滤
     * @param {string} dir 所要上传的本地文件目录
     * @param {string} foldName 本地文件存放在bucket上的目录，可以不传
     * @param {object} options 文件过滤项，选项参考 glob[option] https://www.npmjs.com/package/glob#options，可以不传
     */
    uploadDir(dir, foldName, options = {}) {
        if(!dir) {
            throw new Error('dir is required for uploadDir');
        }
        if(!fs.existsSync(dir)) {
            throw new Error(`dir ${dir} is not exist`);
        }
        return fs.statAsync(dir)
            .then(stat => {
                if(!stat.isDirectory()) {
                    throw new Error(`dir ${dir} is not directory`);
                }
            })
            .then(() => {
                if(!glob) {
                    glob = Promise.promisify(require('glob'));
                }
                return glob('**/*', Object.assign({
                    cwd: dir,
                    dot: false,
                    nodir: true,
                }, options))
            })
            .then((files) => {
                if(!files || !files.length) {
                    return '未找到需要上次的文件';
                }
                return Promise.all(files.map(file => {
                    let objectPath = file;
                    if(foldName) {
                        objectPath = foldName + '/' + file;
                    }
                    return this.object(objectPath).put(path.join(dir, file), Object.assign({ 'content-disposition': '' }, options.headers));
                }));
            });
    }

}

module.exports = Bucket;
